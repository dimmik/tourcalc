@page "/tourlist"
@using TCBlazor.Client.Utils
@using TCalc.Domain
@inject HttpClient Http
@inject TCBlazor.Client.Storage.TourcalcLocalStorage ts
@inject IJSRuntime JsRuntime

<h3>TourList</h3>
@if (tours == null)
{
    <span>Tours loading...</span>
}
else
{
    <TableTemplate Items=@GetTours()  Context="tour" TopPadding="30">
    <TableHeader>
        <th>Tour Name</th>
        <th>Fin</th>
        <th>Arch <input type="checkbox" @bind-value=@ShowArchived/></th>
        <th>Del</th>
    </TableHeader>
    <RowTemplate>
        <td>
                @if (!(tour.Metadata == "Editing"))
                {
                    <NavLink href=@($"tour/{tour.Id}")>@((MarkupString)tour.Name.AsBreakable())</NavLink> 
                    
                } else
                {
                    <span><input type="text" @bind-value=@tour.Name  @onfocusout=@(() => ChangeTourName(tour))/><button>✓</button></span>
                }
            <div style="font-size: xx-small">[@tour.DateCreated.ToString("dd.MM.yyyy HH:mm")] 
            <button @onclick=@(() => tour.Metadata = (tour.Metadata == "Editing" ? "--" : "Editing"))>✎</button>
                

            </div>
        </td>
        <td><input @key=@($"fin_{tour.Id}") type="checkbox" 
            checked=@tour.IsFinalizing 
            @onclick=@(() => OnFinChange(tour))
            />
        </td>
        <td><input  @key=@($"arch_{tour.Id}") type="checkbox" 
            checked=@tour.IsArchived 
            @onclick=@(() => OnArchChange(tour))
            /></td>
        <td><span style="border:dashed; cursor:pointer;" @onclick=@(() => OnDelete(tour))>X</span></td>
    </RowTemplate>
</TableTemplate>
}

@code {
    private TCalc.Domain.TourList? tours = null;
    private bool ShowArchived = false;

    private async Task ChangeTourName(Tour tour)
    {
        await Http.GetFromJsonWithAuthToken<string>($"/api/tour/{tour.Id}/changename", await ts.GetToken(), HttpMethod.Patch, tour);
        await LoadTours();        
    }

    private async Task OnFinChange(Tour tour)
    {
        tour.IsFinalizing = !tour.IsFinalizing;
        await Http.GetFromJsonWithAuthToken<string>($"/api/tour/{tour.Id}/finalizing", await ts.GetToken(), HttpMethod.Patch, tour);
        await LoadTours();
    }
    private async Task OnArchChange(Tour tour)
    {
        tour.IsArchived = !tour.IsArchived;
        await Http.GetFromJsonWithAuthToken<string>($"/api/tour/{tour.Id}/archive", await ts.GetToken(), HttpMethod.Patch, tour);
        await LoadTours();
    }
    async Task OnDelete(Tour tour)
    {
        bool confirmed = await JsRuntime.InvokeAsync<bool>("confirm", $"Delete tour '{tour.Name}'");
        if (confirmed)
        {
            await Http.GetFromJsonWithAuthToken<string>($"/api/tour/{tour.Id}", await ts.GetToken(), HttpMethod.Delete, null);
            await LoadTours();
        }
    }
    protected override async Task OnInitializedAsync()
    {
        await LoadTours();
    }
    private IEnumerable<Tour> GetTours()
    {
        var res = tours?.Tours ?? new Tour[0] ;
        if (!ShowArchived) res = res.Where(t => !t.IsArchived);
        return res;
    }
    private async Task LoadTours()
    {
        var token = await ts.GetToken();
        // TODO pagination, links, all the stuff
        var from = 0;
        var count = 100;
        var code = "";
        tours = await Http.GetFromJsonWithAuthToken<TourList>($"/api/Tour/all/suggested?from={from}&count={count}&code={code}", token);
    }

}
