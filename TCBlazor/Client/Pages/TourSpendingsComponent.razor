@using TCBlazor.Client.Storage;

@inject EnrichedHttpClient Http
@inject TourcalcLocalStorage ts
@inject IJSRuntime JsRuntime

<TableTemplate 
    Items=@(GetSpendingSorted()) 
    Context="spendingItem" 
    TopPadding="30"
    ConditionalItemIdxIncrement=@((s, idx) => !s.Planned)
    ConditionalRowStyle=@((s, idx) => 
    {
        if (s.Planned){
            if (s.Description.StartsWith("Family")){
                return "background-color: aquamarine";
            } else {
                return "background-color: yellow";
            }
        } else {
            return $"background-color: {(idx % 2 == 0 ? "LightCyan" : "white")}";
        }
        //return "";
    })
>
    <TableHeader>
        <th>
            <span style="cursor:pointer;@(sortingField == SortingField.Descr ? "color: blue;" : "")" @onclick=@(() => ToggleSorting(SortingField.Descr))>Spending Description &nbsp;</span>
                        
            <span style="cursor:pointer;@(sortingField == SortingField.Date ? "color: blue;" : "")" @onclick=@(() => ToggleSorting(SortingField.Date))>Dt&nbsp;</span>
            <span style="cursor:pointer;@(sortingField == SortingField.Type ? "color: blue;" : "")" @onclick=@(() => ToggleSorting(SortingField.Type))>Cat&nbsp;</span>
            &nbsp; <span style="cursor: pointer" @onclick=@(() => OnToggleShowPlanned())>[@(ShowPlanned ? "-" : "+")]</span>
            <Select
                @bind-Value=@(filterCategory)
                TItemValue="string"
		        TItem="string"
                AllowClear=@true
                Placeholder="Cat filter"
                Style="display:inline-block"
                DropdownMatchSelectWidth=@false
                >
                <SelectOptions>
			            @foreach(var c in (Tour?
                                .Spendings?
                                .Where(s => !s.Planned)?
                                .Select(s => s.Type)?.Where(cc => !string.IsNullOrWhiteSpace(cc)) ?? new string[0])
                                .Distinct())
			            {
				            <SelectOption TItemValue="string" TItem="string" Value=@c Label=@c />
			            }
		            </SelectOptions>
            </Select>
            </th>
        <th><span style="cursor:pointer;@(sortingField == SortingField.From ? "color: blue;" : "")" @onclick=@(() => ToggleSorting(SortingField.From))>From</span></th>
        <th><span style="cursor:pointer;@(sortingField == SortingField.Amount ? "color: blue;" : "")" @onclick=@(() => ToggleSorting(SortingField.Amount))>Amount</span></th>
        <th>Recepients</th>
    </TableHeader>
    <RowTemplate>
        @{
            var spending = spendingItem.Item1;
            var idx = spendingItem.Item2;
        }
        <td>
            @if (!spending.Planned)
            {
                <span style="cursor:pointer;" 
                @onclick=@(() => OnSpendingDeleteClicked(spending))>
                <b>X&nbsp;</b>
                </span>
                <span>&nbsp;@idx.</span>
            }
            
            @((MarkupString)spending.Description.AsBreakable())
            <div style="font-size: xx-small">[@spending.DateCreated.ToString("dd.MM.yyyy HH:mm")] <b>@spending.Type</b>
                @if (EditActionTemplate != null)
                {
                    <span>@EditActionTemplate(spending)</span>
                }
                </div>
        </td>
        <td>@((MarkupString)((Tour?.Persons ?? new List<Person>()).Where(p => p.GUID == spending.FromGuid).FirstOrDefault()?.Name ?? "").AsBreakable())</td>
        <td>@spending.AmountInCents</td>
        <td>@if (spending.ToAll)
            {
                <span style="background-color:green;color:yellow;font-size:xx-small">ALL</span>
            }    
            else 
            {
                <span style="font-size:xx-small">
                    @(
                        (MarkupString)string.Join(",",
                            spending
                            .ToGuid
                            .Select(g => (Tour?.Persons ?? new List<Person>())
                                    .Where(p => p.GUID == g)
                                    .FirstOrDefault()?.Name)
                             ).AsBreakable()
                     )
                </span>
                if (!spending.IsPartialWeighted && spending.ToGuid.Count > 1)
                {
                    <div style="color:darkcyan; font-size: xx-small"><b><i>NOT Weighted</i></b></div>
                }
            }
                </td>
    </RowTemplate>
</TableTemplate>

@code {
    [Parameter]
    public Tour? Tour { get; set; } = null;

    [Parameter]
    public bool ShowPlanned { get; set; } = false;

    [Parameter]
    public Action? OnToggleShowPlanned { get; set; } = null;

    private UISettings settings = new UISettings();

    protected override async Task OnInitializedAsync()
    {
        settings = await ts.GetUISettings();
    }

    protected override void OnParametersSet()
    {
        //ShowPlanned = Tour?.IsFinalizing ?? false;
        if (OnToggleShowPlanned == null)
        {
            OnToggleShowPlanned = () => ShowPlanned = !ShowPlanned;
        }
        InitSortPredicates();
    }

    private void InitSortPredicates()
    {
        sortPredicates[SortingField.From] = (s) => (Tour?.Persons?.FirstOrDefault(p => p.GUID == s.FromGuid)?.Name ?? "");
        sortPredicates[SortingField.Amount] = (s) => s.AmountInCents.ToString("00000000000000");
        sortPredicates[SortingField.Descr] = (s) => s.Description;
        sortPredicates[SortingField.Date] = (s) => $"{s.DateCreated: yyyyMMdd_HHmmss}";
        sortPredicates[SortingField.Type] = (s) => string.IsNullOrWhiteSpace(s.Type) ? new string(Char.MaxValue, 1) : s.Type;
    }
    [Parameter]
    public Func<IEnumerable<Spending>, IEnumerable<Spending>> SpendingListPreProcessor { get; set; } = (s) => s;

    private SortingField? sortingField = null;
    private SortingType sortingType = SortingType.Asc;
    private void ToggleSorting(SortingField field)
    {
        if (sortingField != field)
        {
            sortingField = field;
            sortingType = SortingType.Asc;
        } 
        else
        {
            if (sortingType == SortingType.Asc){
                sortingType = SortingType.Desc;
            } else 
            {
                sortingField = null;
            }
        }
    }
    private IEnumerable<Spending> SortByPredicate(IEnumerable<Spending> seq, SortingType st, Func<Spending, string> predicate)
    {
        if (st == SortingType.Asc)
        {
            return seq.OrderBy(s => !s.Planned).ThenBy(predicate);
        } else
        {
            return seq.OrderBy(s => !s.Planned).ThenByDescending(predicate);                
        }
    }

    Dictionary<SortingField, Func<Spending, string>> sortPredicates = new Dictionary<SortingField, Func<Spending, string>>();

    private IEnumerable<Spending> FieldSort(IEnumerable<Spending> seq)
    {
        if (sortingField == null) return seq;
        if (sortPredicates.ContainsKey(sortingField.Value))
        {
            return SortByPredicate(seq, sortingType, sortPredicates[sortingField.Value]);
        }
        return seq;
    }
    private string filterCategory = "";

    private IEnumerable<Spending> FieldFilter(IEnumerable<Spending> seq)
    {
        if (!string.IsNullOrWhiteSpace(filterCategory))
        {
            return seq.Where(s => s.Type == filterCategory);
        }
        return seq;
    }

    public IEnumerable<Spending> GetSpendingSorted()
    {
        IEnumerable<Spending> res = (Tour?.Spendings ?? new List<Spending>());
        var planned = res.Where(s => s.Planned && Math.Abs(s.AmountInCents) > settings.MinimumMeaningfulDebt);
        var real = res.Where(s => !s.Planned);
        planned = planned
            .OrderBy(s => s.Description.StartsWith("Family") ? 0 : 1) // first family
            .ThenBy(s => (Tour?.Persons ?? new List<Person>()).FirstOrDefault(p => p.GUID == s.FromGuid)?.Name ?? "") // then by name
            .ThenByDescending(s => s.AmountInCents) // then by amount
            ;
        real = real.OrderBy(s => s.DateCreated);

        var preprocessed = SpendingListPreProcessor((ShowPlanned ? planned : new Spending[0]).Concat(real).ToList());
        var sorted = FieldSort(preprocessed);
        var filtered = FieldFilter(sorted);
        return filtered;
    }

    [Parameter]
    public RenderFragment<Spending>? EditActionTemplate { get; set; }

    [Parameter]
    public Func<Spending, Task> OnSpendingDelete { get; set; } = async (s) => { };

    async Task OnSpendingDeleteClicked(Spending s)
    {
        bool confirmed = await JsRuntime.InvokeAsync<bool>("confirm", $"Delete spending '{s.Description}'");
        if (confirmed)
        {
            await OnSpendingDelete(s);
        }
    }
    enum SortingType
    {
        Asc, Desc
    }
    enum SortingField
    {
        From, Descr, Date, Type, Amount
    }
}
