@using ColorSequenceGenerator
<table>
    <tr><td style="width: 160px; height: 160px; padding: 5px; vertical-align: top;">
    <div style="
        border-radius: 100%;
        width: 100%;
        aspect-ratio: 1;
        background: conic-gradient(@(string.Join(", ", 
                GetFromTo(AnglesColorsAndNames.Select(acn => acn.Item1)) // (0, 8), (8, 17), (17, 95) ...
                .Zip(AnglesColorsAndNames)
                .Select(acn => new {Color=acn.Second.Item2, FromDeg=acn.First.Item1, ToDeg=acn.First.Item2})
                .Select(acn => $"{acn.Color} {acn.FromDeg}deg {acn.ToDeg}deg")))
            );
    "></div>

</td>
<td style="padding: 5px; font-size: x-small; vertical-align:top;">
@foreach (var acn in AnglesColorsAndNames)
{
  var nm = acn.Item3;
  var color = acn.Item2;
  var perc = acn.Item1 * 100.0 / 360;
  <div>
        <span style="width:7px;background-color:@color">&nbsp;&nbsp;&nbsp;</span><b>&nbsp;@nm</b> @($"{perc:0.0}%")
  </div>
}
@if (ShowDebugUI){
                <AntDesign.InputNumber Min="1000" Max="5000" Step="1" Style="margin:0 16px;" @bind-Value="@nextColorMultiplier"
                                   TValue="int"
                OnChange=@(() => {UpdateColors(); StateHasChanged();}) />
                <RadzenColorPicker @bind-Value=@color Change=@((v) => {UpdateColors(); StateHasChanged();}) />
}
</td>
</tr>
</table>
@code {
    [Parameter]
    public IEnumerable<(string name, int amount)> Data { get; set; } = new List<(string, int)>();
    [Parameter]
    public int nextColorMultiplier
    {
        get
        {
            return (int)(csg.Magic * 1000);
        }
        set
        {
            csg.Magic = value * 1.0 / 1000;
        }
    }
    [Parameter]
    public bool ShowDebugUI { get; set; } = false;


    private List<(int, string, string)> AnglesColorsAndNames { get; set; } = new();
    protected override void OnParametersSet()
    {
        UpdateColors();
    }
    private void UpdateColors()
    {
        AnglesColorsAndNames = GetAnglesColorsAndNames().ToList();
    }
    string color { get
        {
            return $"rgb({csg.Seed.Red},{csg.Seed.Green},{csg.Seed.Blue})";
        } set
        {
            var trimmed = value.Trim('r', 'g', 'b', 'a', '(', ')');
            string[] rgb = trimmed.Split(',', ' ').Where(s => !string.IsNullOrWhiteSpace(s)).ToArray();
            csg.Seed = new RGB(byte.Parse(rgb[0]), byte.Parse(rgb[1]), byte.Parse(rgb[2]));
        } 
    }
    private readonly ColorSequenceGenerator csg = new();
    private IEnumerable<string> Colors()
    {
        return csg.ColorSequence().Select(c => c.ToString());
    }

    public IEnumerable<(int, int)> GetFromTo(IEnumerable<int> seq)
    {
        int i = 0;
        foreach (var s in seq)
        {
            yield return (i, i + s);
            i = i + s;
        }
    }
    private string guid = Guid.NewGuid().ToString();
    private IEnumerable<(int, string, string)> GetAnglesColorsAndNames()
    {
        if (!Data.Any()) Data = new[] { ("n/a", 0) };
        var total = Data.Select(i => i.amount).Sum();
        var a = Data
            .Select(i => (int)((i.amount * 360.0 / total)))
            .ToList();
        if (a.Sum() < 360)
        {
            if (a.Any())
            {
                a[a.IndexOf(a.Max())] = a.Max() + (360 - a.Sum());
            } else
            {
                Console.WriteLine($"({guid}) Hmm... No elements?.. {a.Count} Magic...");
            }
        }
        
        var res = a
        .Zip(Data.Select(i => i.name))
        .OrderByDescending(i => i.First)
        .Zip(Colors().Take(a.Count()))
        .Select(i => (i.First.First, i.Second, i.First.Second)) // (angle, color, name)
        ;
        return res;
    }
}
